---
layout: post
title: "Design for Testability, NMock and CodeCoverage"
date: 2006-12-29T16:09:00Z
modtime: 2006-12-29T16:09:00Z
pubdate: 2006-12-29T16:09:00Z
originalurl: "http://bloggingabout.net/blogs/rene/default.aspx/blogs/rene/archive/2006/12/29/design-for-testability-nmock-and-codecoverage.aspx"
---


<p>In one of my previous <a href="/blogs/rene/archive/2006/12/07/Delete-builds-during-the-build.aspx">posts</a> I showed some code calling the Team Foundation Server. During test runs I had a reference to our production TFS box. You can imagine that carefull testing was the first law to obey, hence the built-in option 'Emulate' to not really destroy anything.</p><p>For Unit testing this approach was somewhat cumbersome so I needed a better approach. My first class model looked like this:</p><p><a href="/UserFiles/rene schrieken/WindowsLiveWriter/DesignforTestabilityNMockandCodeCoverage_12EBA/ClassDiagram1[2].png"><img src="/UserFiles/rene schrieken/WindowsLiveWriter/DesignforTestabilityNMockandCodeCoverage_12EBA/ClassDiagram1_thumb.png" style="BORDER-TOP-WIDTH: 0px; BORDER-LEFT-WIDTH: 0px; BORDER-BOTTOM-WIDTH: 0px; BORDER-RIGHT-WIDTH: 0px" height="302" border="0" width="640" /></a></p><p>In this model I have two dependencies on two external types in the assembly <a href="http://affiliate.vsipmembers.com/affiliate/downloadfiles.aspx">Microsoft.TeamFoundation.Build.Proxy.</a> During Unit testing I want to call an instance of those classes that have the same signature. NMock provide such functionality. It simulates an actual class. To instantiate an Mock class you need to provide it an interface. Time for some refactoring.</p><p><a href="/UserFiles/rene schrieken/WindowsLiveWriter/DesignforTestabilityNMockandCodeCoverage_12EBA/ClassDiagram2[2].png"><img src="/UserFiles/rene schrieken/WindowsLiveWriter/DesignforTestabilityNMockandCodeCoverage_12EBA/ClassDiagram2_thumb.png" style="BORDER-TOP-WIDTH: 0px; BORDER-LEFT-WIDTH: 0px; BORDER-BOTTOM-WIDTH: 0px; BORDER-RIGHT-WIDTH: 0px" height="290" border="0" width="640" /></a></p><p>As you can see the Action classes now depend on the new Interface ITeamFoundationServer. The class TeamFoundationServer implements that interface and has dependencies on the TFS classes. The Action classes obtain an instance to an implementation of ITeamFoundationServer by calling the static property Instance on the TeamFoundationServer class. So this class also acts as a Factory.</p><h2>Mock</h2><p>When we are running a unit test we want to provide our own implementation of the ITeamFoundationServer interface. For this to happen we need a form of dependency injection. As I do not want to introduce a complete, full blown dependency injection framework (I could have used ObjectBuilder), I simply provide a dependency injection constructor on the TeamFoundationServer class. The constructor accepts an ITeamFoundationServer implementation and sets the corresponding private static field _Instance. The default constructor is private which prevents instantiating the TeamFoundationServer class from non-testing code.</p><p>After you added a reference to the <a href="http://nmock.sourceforge.net/">NMock</a> assembly you can start creating Mocks in your test method. First you start off with creating a Mockery object and then you're ready for creating a mock object for the interface. The instance returned from that call is injected in our code by the means of the dependency constructor as shown in the following snippet:</p><p><font size="1" face="Courier New">Mockery mock = new Mockery();
<br />
ITeamFoundationServer itfsMock = (ITeamFoundationServer) mock.NewMock(typeof(ITeamFoundationServer));
<br /></font><font size="1" face="Courier New">TeamFoundationServer tfsDummy = new TeamFoundationServer(itfsMock);</font></p><p>The next step is to define what call will be expected on the interface and which return values should be delivered in that case. For example:</p><p><font size="1" face="Courier New">Expect.Once.On(itfsMock).Method("GetListOfBuilds").With(new object[] {"par1", "par2"}).Will(Return.Value(TestData()));</font></p><p>This tells the NMock framework to expect one call to GetListOfBuilds with two string parameters. That call will return testdata. The testdata is choosen so that it exercises different execution paths to maximize codecoverage. Now you're ready to make the call to your class/classes under test. As the call returns one final call to the mock framework will check that all of our expected calls have been taking place.</p><p><font size="1" face="Courier New">mock.VerifyAllExpectationsHaveBeenMet();</font></p><p>We now have a unit test that can safely run without the need for an up-and-running teamfoundationserver. So everybody can relax...</p><h2>CodeCoverage</h2><p>The best thing of the mock object is the flexibility in accepting and returning data for testcases that would require running complex database scripts or infrastructure. You can even throw exceptions. Having said that there is no reason for a codecoverage of less than 100%.</p><p>If you have no ambition you're close to death. It is however hard to reach 100%. In my case the real implementation was also taken into account for the coverage and was off-course not covered by any test. In the first run only 60% of the code was covered. By adding more testcases (and richer testdata), refactor out common code and having the mock framework throw excpetions I achieved over 80%.</p><p>To reach the 90% I needed some trickery. Inspection of the non-coveraged code blocks revealed that some private constructors were not called. With some reflection magic that can be solved:</p><p><font size="1" face="Courier New">Type tfsType = typeof(TeamFoundationServer);
<br />
ConstructorInfo[] call = tfsType.GetConstructors(BindingFlags.NonPublic | BindingFlags.CreateInstance | BindingFlags.Instance);
<br />
object tfsInstance = call[0].Invoke(null);</font></p><p>Also the Dispose method was not fully covered because some internal fields where never set. Also for this CodeCoverageCase some reflection magic was needed. This is how you achieve that. Pay attention to the fact that this field is private so it can not be set from the testcode.</p><p><font size="1" face="Courier New">tfsInstance.InvokeMember("_Instance",
<br />
BindingFlags.Instance | BindingFlags.SetField | BindingFlags.NonPublic,
<br />
null,
<br />
tfsInstance,
<br />
new object[] { tfsInstance });</font></p><p>Calling Dispose now did exercise all code paths.</p><p><a href="/UserFiles/rene schrieken/WindowsLiveWriter/DesignforTestabilityNMockandCodeCoverage_12EBA/codecoverage.gif" target="_new"><img src="/UserFiles/rene schrieken/WindowsLiveWriter/DesignforTestabilityNMockandCodeCoverage_12EBA/codecoverage_thumb.gif" alt="Click to enlarge" height="240" width="214" /></a></p><h2>Conclusion</h2><p>If you're serious about Unit testing you need to design for testability. A good test design enables the Unit test to insert Mock objects without cluttering you're code with test artifacts. Using Mock objects gives you the ability to test even complex sceanrio's relatively simple. Using Code coverage to measure the effectiveness of your unit tests is a best practise. To achieve top code coverage ratings you might need some magic.</p>
